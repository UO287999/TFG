}, error = function(e) NULL)
if (!is.null(fit)) {
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
tests <- testResiduals(sim, plot = FALSE)
p_uniform <- tests$uniformity$p.value
p_disp <- tests$dispersion$p.value
p_out <- tests$outliers$p.value
if (p_uniform > 0.05 & p_disp > 0.05 & p_out > 0.05) {
cat("‚úÖ Modelo v√°lido encontrado con:", paste(combo, collapse = ", "), "\n")
modelos_validos[[paste(combo, collapse = "_")]] <- list(
formula = formula,
modelo = fit,
pvalues = c(uniformity = p_uniform, dispersion = p_disp, outliers = p_out)
)
encontrado <- TRUE
} else {
cat("‚ùå No v√°lido (uniformity:", round(p_uniform, 4),
"dispersion:", round(p_disp, 4),
"outliers:", round(p_out, 4), ")\n")
}
}
}
}
}
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Lista de variables candidatas (year incluida como fija si aparece en combo)
vars <- c("year", "regional_indicator", "gdp", "support", "life_exp", "freedom",
"generosity", "corruption", "status", "political_rights",
"civil_liberties", "fair_election", "regime_category",
"electoral_category", "presidential")
# Para guardar el primer modelo v√°lido
modelos_validos <- list()
encontrado <- FALSE  # Flag para detener al encontrar modelo v√°lido
for (k in 2:length(vars)) {
if (encontrado) break
cat("\nBuscando combinaciones de tama√±o", k, "...\n")
combinaciones <- combn(vars, k, simplify = FALSE)
for (combo in combinaciones) {
if (encontrado) break
cat("Probando combinaci√≥n:", paste(combo, collapse = ", "), "\n")
# Construir f√≥rmula con efectos fijos y aleatorios
efectos_fijos <- paste(combo, collapse = " + ")
formula <- as.formula(paste0("happiness_score ~ ", efectos_fijos,
" + (1 + regional_indicator | country)"))
# Intentar ajustar el modelo
fit <- tryCatch({
glmmTMB(formula, data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail)
}, error = function(e) NULL)
if (!is.null(fit)) {
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
tests <- testResiduals(sim, plot = FALSE)
# Validaci√≥n optimizada: salir al primer test no superado
p_uniform <- tests$uniformity$p.value
if (p_uniform <= 0.05) {
cat("‚ùå No v√°lido (uniformity:", round(p_uniform, 4), ")\n")
next
}
p_disp <- tests$dispersion$p.value
if (p_disp <= 0.05) {
cat("‚ùå No v√°lido (dispersion:", round(p_disp, 4), ")\n")
next
}
p_out <- tests$outliers$p.value
if (p_out <= 0.05) {
cat("‚ùå No v√°lido (outliers:", round(p_out, 4), ")\n")
next
}
# Si pasa los 3 tests
cat("‚úÖ Modelo v√°lido encontrado con:", paste(combo, collapse = ", "), "\n")
modelos_validos[[paste(combo, collapse = "_")]] <- list(
formula = formula,
modelo = fit,
pvalues = c(uniformity = p_uniform, dispersion = p_disp, outliers = p_out)
)
encontrado <- TRUE
}
}
}
}
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Lista de variables candidatas (year incluida como fija si aparece en combo)
vars <- c("year", "regional_indicator", "gdp", "support", "life_exp", "freedom",
"generosity", "corruption", "status", "political_rights",
"civil_liberties", "fair_election", "regime_category",
"electoral_category", "presidential")
# Para guardar resultados del test de uniformidad
resultados_uniformity <- list()
for (k in 2:length(vars)) {
cat("\nBuscando combinaciones de tama√±o", k, "...\n")
combinaciones <- combn(vars, k, simplify = FALSE)
for (combo in combinaciones) {
cat("Probando combinaci√≥n:", paste(combo, collapse = ", "), "\n")
# Construir f√≥rmula con efectos fijos y aleatorios
efectos_fijos <- paste(combo, collapse = " + ")
formula <- as.formula(paste0("happiness_score ~ ", efectos_fijos,
" + (1 + regional_indicator | country)"))
# Intentar ajustar el modelo
fit <- tryCatch({
glmmTMB(formula, data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail)
}, error = function(e) NULL)
if (!is.null(fit)) {
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
tests <- testResiduals(sim, plot = FALSE)
p_uniform <- tests$uniformity$p.value
cat("üîé p-uniformity =", round(p_uniform, 4), "\n")
resultados_uniformity[[paste(combo, collapse = "_")]] <- p_uniform
}
}
}
}
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Lista de variables candidatas (year incluida como fija si aparece en combo)
vars <- c("year", "regional_indicator", "gdp", "support", "life_exp", "freedom",
"generosity", "corruption", "status", "political_rights",
"civil_liberties", "fair_election", "regime_category",
"electoral_category", "presidential")
# Para guardar el primer modelo v√°lido
modelos_validos <- list()
encontrado <- FALSE  # Flag para detener al encontrar modelo v√°lido
for (k in 2:length(vars)) {
if (encontrado) break
cat("\nBuscando combinaciones de tama√±o", k, "...\n")
combinaciones <- combn(vars, k, simplify = FALSE)
for (combo in combinaciones) {
if (encontrado) break
cat("Probando combinaci√≥n:", paste(combo, collapse = ", "), "\n")
# Construir f√≥rmula con efectos fijos y aleatorios
efectos_fijos <- paste(combo, collapse = " + ")
formula <- as.formula(paste0("happiness_score ~ ", efectos_fijos,
" + (1 + regional_indicator | country)"))
# Intentar ajustar el modelo
fit <- tryCatch({
glmmTMB(formula, data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail)
}, error = function(e) NULL)
if (!is.null(fit)) {
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
tests <- testResiduals(sim, plot = FALSE)
# Validaci√≥n optimizada: salir al primer test no superado
p_uniform <- tests$uniformity$p.value
if (p_uniform <= 0.05) {
cat("‚ùå No v√°lido (uniformity:", round(p_uniform, 4), ")\n")
next
}
p_disp <- tests$dispersion$p.value
if (p_disp <= 0.05) {
cat("‚ùå No v√°lido (dispersion:", round(p_disp, 4), ")\n")
next
}
p_out <- tests$outliers$p.value
if (p_out <= 0.05) {
cat("‚ùå No v√°lido (outliers:", round(p_out, 4), ")\n")
next
}
# Si pasa los 3 tests
cat("‚úÖ Modelo v√°lido encontrado con:", paste(combo, collapse = ", "), "\n")
modelos_validos[[paste(combo, collapse = "_")]] <- list(
formula = formula,
modelo = fit,
pvalues = c(uniformity = p_uniform, dispersion = p_disp, outliers = p_out)
)
encontrado <- TRUE
}
}
}
}
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Modelo GLMM v√°lido
glmm_valido <- glmmTMB(
happiness_score ~ support + life_exp + (1 + regional_indicator | country),
data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail
)
summary(glmm_valido)
library(performance)
r2(glmm_valido)
#| label: fig-qqplot-residuos3
#| echo: false
#| warning: false
#| fig-cap: "QQ-plot de los residuos simulados del modelo mixto"
sim_res <- DHARMa::simulateResiduals(fittedModel = glmm_valido)
plotQQunif(sim_res)
#| label: fig-dispersion-residuos3
#| echo: false
#| warning: false
#| fig-cap: "Dispersi√≥n de los residuos simulados frente a los valores predichos"
plotResiduals(sim_res)
#| label: fig-test-residuos3
#| echo: false
#| warning: false
#| fig-cap: "Resultados del test formal de uniformidad aplicado a los residuos simulados"
testResiduals(sim_res)
#| label: fig-qqplot-residuos3
#| echo: false
#| warning: false
#| fig-cap: "QQ-plot de los residuos simulados del modelo mixto"
sim_res <- DHARMa::simulateResiduals(fittedModel = glmm_valido)
plotQQunif(sim_res)
#| label: fig-dispersion-residuos3
#| echo: false
#| warning: false
#| fig-cap: "Dispersi√≥n de los residuos simulados frente a los valores predichos"
plotResiduals(sim_res)
#| label: fig-test-residuos3
#| echo: false
#| warning: false
#| fig-cap: "Resultados del test formal de uniformidad aplicado a los residuos simulados"
testResiduals(sim_res)
# Cargar librer√≠as necesarias
library(glmmTMB)
library(dplyr)
# Crear una copia del dataset para 2025
datos_2025 <- df_unificado
datos_2025$year <- 2025
# Realizar predicci√≥n usando el modelo GLMM v√°lido
# allow.new.levels = TRUE permite predecir aunque haya pa√≠ses nuevos o no observados en la estimaci√≥n
datos_2025$happiness_pred_2025 <- predict(glmm_valido, newdata = datos_2025, type = "response", allow.new.levels = TRUE)
# Agrupar por pa√≠s y calcular la media (por si hay m√∫ltiples filas por pa√≠s)
ranking_glmm_2025 <- datos_2025 %>%
group_by(country) %>%
summarise(happiness_pred_2025 = mean(happiness_pred_2025, na.rm = TRUE)) %>%
arrange(desc(happiness_pred_2025)) %>%
mutate(rank = row_number())
# Mostrar el top 10 y bottom 10 del ranking
print(head(ranking_glmm_2025, 10))
print(tail(ranking_glmm_2025, 10))
# Predicci√≥n espec√≠fica para Espa√±a
ranking_glmm_2025 %>% filter(country == "Spain")
# Comparaci√≥n con 2024
ranking_2024 <- df_unificado %>%
filter(year == 2024) %>%
select(country, happiness_score) %>%
group_by(country) %>%
summarise(happiness_score = mean(happiness_score, na.rm = TRUE)) %>%
arrange(desc(happiness_score)) %>%
mutate(rank_2024 = row_number())
# Puntuaci√≥n y ranking de Espa√±a en 2024
ranking_2024 %>% filter(country == "Spain")
shiny::runApp('App')
runApp('App')
runApp('App')
runApp('App')
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Modelo GLMM v√°lido
glmm_valido <- glmmTMB(
happiness_score ~ support + life_exp + (1 + regional_indicator | country),
data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail
)
summary(glmm_valido)
runApp('App')
runApp('App')
summary(modelo_seleccionado)
# Cargar librer√≠as necesarias
library(lme4)
library(MuMIn)
library(DHARMa)
# Ajustar el modelo base para selecci√≥n (con df_unificado y na.fail)
modelo_base <- lmer(
happiness_score ~ regional_indicator + gdp + support + life_exp + freedom +
generosity + corruption + status + political_rights + civil_liberties +
fair_election + regime_category + democracy + electoral_category +
presidential + alternation + year +
(1 + year | country),
data = df_unificado,
REML = FALSE,
na.action = na.fail
)
# Aplicar selecci√≥n por AIC
# modelos_dredge <- dredge(modelo_base, trace = FALSE)
# modelo_seleccionado <- get.models(modelos_dredge, 1)[[1]]
modelo_seleccionado <- modelo_base <- lmer(
happiness_score ~ civil_liberties + electoral_category + freedom +
gdp + life_exp + political_rights + regime_category + regional_indicator +
status + support + year + (1 + year | country),
data = df_unificado,
REML = FALSE,
na.action = na.fail
)
summary(modelo_seleccionado)
summary(modelo_seleccionado)
library(performance)
r2(modelo_seleccionado)
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
runApp('App')
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Modelo GLMM v√°lido
glmm_valido <- glmmTMB(
happiness_score ~ support + life_exp + (1 + regional_indicator | country),
data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail
)
summary(glmm_valido)
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Lista de variables candidatas (year incluida como fija si aparece en combo)
vars <- c("year", "regional_indicator", "gdp", "support", "life_exp", "freedom",
"generosity", "corruption", "status", "political_rights",
"civil_liberties", "fair_election", "regime_category",
"electoral_category", "presidential")
# Para guardar el primer modelo v√°lido
modelo_valido <- NULL
encontrado <- FALSE  # Flag para detener al encontrar modelo v√°lido
for (k in 2:length(vars)) {
if (encontrado) break
cat("\nBuscando combinaciones de tama√±o", k, "...\n")
combinaciones <- combn(vars, k, simplify = FALSE)
for (combo in combinaciones) {
if (encontrado) break
cat("Probando combinaci√≥n:", paste(combo, collapse = ", "), "\n")
# Construir f√≥rmula con efectos fijos y aleatorio (solo regional_indicator)
efectos_fijos <- paste(combo, collapse = " + ")
formula <- as.formula(paste0("happiness_score ~ ", efectos_fijos,
" + (1 | regional_indicator)"))
# Ajustar modelo
fit <- tryCatch({
glmmTMB(formula, data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail)
}, error = function(e) NULL)
if (!is.null(fit)) {
# AIC debe ser num√©rico
aic_val <- tryCatch(AIC(fit), error = function(e) NA)
if (is.na(aic_val)) {
cat("‚ö†Ô∏è AIC es NA. Se descarta.\n")
next
}
# Validaci√≥n
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
# Validaci√≥n optimizada (corta al fallar cualquier test)
p_uniform <- testUniformity(sim)$p.value
if (p_uniform <= 0.05) {
cat("‚ùå No v√°lido (uniformity =", round(p_uniform, 4), ")\n")
next
}
p_disp <- testDispersion(sim)$p.value
if (p_disp <= 0.05) {
cat("‚ùå No v√°lido (dispersion =", round(p_disp, 4), ")\n")
next
}
p_out <- testOutliers(sim)$p.value
if (p_out <= 0.05) {
cat("‚ùå No v√°lido (outliers =", round(p_out, 4), ")\n")
next
}
# ‚úÖ Si pasa todos los tests y AIC es v√°lido
cat("‚úÖ Modelo v√°lido encontrado con:", paste(combo, collapse = ", "),
"| AIC =", round(aic_val, 2), "\n")
modelo_valido <- list(
formula = formula,
modelo = fit,
AIC = aic_val,
pvalues = c(uniformity = p_uniform, dispersion = p_disp, outliers = p_out)
)
encontrado <- TRUE
}
}
}
}
# Resultado final
if (!is.null(modelo_valido)) {
print(modelo_valido$formula)
print(paste("AIC:", modelo_valido$AIC))
print("P-valores de los tests:")
print(modelo_valido$pvalues)
} else {
cat("‚ùå No se encontr√≥ ning√∫n modelo v√°lido con AIC num√©rico.\n")
}
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Modelo GLMM v√°lido
glmm_valido <- glmmTMB(
happiness_score ~ life_exp + corruption + (1 + regional_indicator | country),
data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail
)
summary(glmm_valido)
# Cargar librer√≠as necesarias
library(glmmTMB)
library(MuMIn)
library(DHARMa)
library(tidyverse)
# Lista de variables candidatas (year incluida como fija si aparece en combo)
vars <- c("year", "regional_indicator", "gdp", "support", "life_exp", "freedom",
"generosity", "corruption", "status", "political_rights",
"civil_liberties", "fair_election", "regime_category",
"electoral_category", "presidential")
# Para guardar el primer modelo v√°lido
modelo_valido <- NULL
encontrado <- FALSE  # Flag para detener al encontrar modelo v√°lido
for (k in 2:length(vars)) {
if (encontrado) break
cat("\nBuscando combinaciones de tama√±o", k, "...\n")
combinaciones <- combn(vars, k, simplify = FALSE)
for (combo in combinaciones) {
if (encontrado) break
cat("Probando combinaci√≥n:", paste(combo, collapse = ", "), "\n")
# Construir f√≥rmula con efectos fijos y aleatorio (solo regional_indicator)
efectos_fijos <- paste(combo, collapse = " + ")
formula <- as.formula(paste0("happiness_score ~ ", efectos_fijos,
" + (1 + regional_indicator | country)"))
# Ajustar modelo
fit <- tryCatch({
glmmTMB(formula, data = df_unificado,
family = Gamma(link = "log"),
na.action = na.fail)
}, error = function(e) NULL)
if (!is.null(fit)) {
# AIC debe ser num√©rico
aic_val <- tryCatch(AIC(fit), error = function(e) NA)
if (is.na(aic_val)) {
cat("‚ö†Ô∏è AIC es NA. Se descarta.\n")
next
}
# Validaci√≥n
sim <- tryCatch({
simulateResiduals(fittedModel = fit, plot = FALSE)
}, error = function(e) NULL)
if (!is.null(sim)) {
# Validaci√≥n optimizada (corta al fallar cualquier test)
p_uniform <- testUniformity(sim)$p.value
if (p_uniform <= 0.05) {
cat("‚ùå No v√°lido (uniformity =", round(p_uniform, 4), ")\n")
next
}
p_disp <- testDispersion(sim)$p.value
if (p_disp <= 0.05) {
cat("‚ùå No v√°lido (dispersion =", round(p_disp, 4), ")\n")
next
}
p_out <- testOutliers(sim)$p.value
if (p_out <= 0.05) {
cat("‚ùå No v√°lido (outliers =", round(p_out, 4), ")\n")
next
}
# ‚úÖ Si pasa todos los tests y AIC es v√°lido
cat("‚úÖ Modelo v√°lido encontrado con:", paste(combo, collapse = ", "),
"| AIC =", round(aic_val, 2), "\n")
modelo_valido <- list(
formula = formula,
modelo = fit,
AIC = aic_val,
pvalues = c(uniformity = p_uniform, dispersion = p_disp, outliers = p_out)
)
encontrado <- TRUE
}
}
}
}
