<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>cap1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="cap1_files/libs/clipboard/clipboard.min.js"></script>
<script src="cap1_files/libs/quarto-html/quarto.js"></script>
<script src="cap1_files/libs/quarto-html/popper.min.js"></script>
<script src="cap1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="cap1_files/libs/quarto-html/anchor.min.js"></script>
<link href="cap1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="cap1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="cap1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="cap1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="cap1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>En las últimas décadas, numerosos gobiernos e instituciones internacionales han comenzado a incorporar indicadores de bienestar subjetivo en sus sistemas estadísticos, reconociendo que las métricas tradicionales como el Producto Interior Bruto (PIB) no bastan por sí solas para evaluar el progreso de una sociedad. En este contexto, surge el World Happiness Report, una iniciativa impulsada por las Naciones Unidas que, desde 2012, proporciona una evaluación anual del nivel de felicidad de los países a partir de encuestas globales y datos objetivos relacionados con factores económicos, sociales y políticos.</p>
<p>Este creciente interés por medir y comprender la felicidad plantea nuevos retos analíticos. A diferencia de otros indicadores, la felicidad presenta una fuerte variabilidad interindividual e intertemporal, lo que exige metodologías estadísticas capaces de capturar tanto las diferencias entre países como las trayectorias temporales dentro de cada uno. En este sentido, el uso de modelos longitudinales y estructuras jerárquicas se revela como un enfoque adecuado para estudiar el fenómeno de forma rigurosa y con capacidad predictiva.</p>
<section id="objetivo-del-trabajo" class="level2">
<h2 class="anchored" data-anchor-id="objetivo-del-trabajo">Objetivo del trabajo</h2>
<p>El objetivo principal de este Trabajo de Fin de Grado es analizar la evolución de la felicidad a nivel mundial mediante técnicas estadísticas avanzadas, en particular modelos mixtos (lineales y generalizados), utilizando datos longitudinales del World Happiness Report enriquecidos con variables políticas. El trabajo busca no solo identificar los factores que más influyen en el bienestar subjetivo, sino también construir una herramienta interactiva que permita visualizar, modelizar y predecir el Happiness Score de forma accesible y reproducible.</p>
<p>De forma más específica, el trabajo plantea integrar y limpiar diversas fuentes de datos sobre felicidad, condiciones socioeconómicas y contexto político, aplicar técnicas de análisis exploratorio para identificar patrones regionales y temporales en la evolución del bienestar, ajustar modelos mixtos que respeten la estructura jerárquica de los datos (países, regiones, años), evaluar el ajuste y la validez de dichos modelos utilizando criterios estadísticos adecuados, desarrollar una aplicación Shiny en R que permita replicar los análisis y explorar distintas configuraciones de modelos, y generar predicciones del Happiness Score para el año 2025.</p>
<p>El trabajo adopta una perspectiva cuantitativa, basada en el uso de técnicas estadísticas robustas para modelar datos longitudinales. Se parte de una base de datos principal (World Happiness Report 2015–2024), a la que se añaden variables políticas obtenidas de fuentes como Freedom in the World y Democracy Data. Estas variables, aunque están disponibles solo para el año 2020, se han replicado a todos los años del período para permitir su uso como predictores fijos. A nivel metodológico, el análisis se estructura en tres niveles: una exploración inicial de los datos, que incluye limpieza, imputación de valores perdidos, análisis de outliers y visualizaciones; el ajuste de modelos estadísticos, utilizando modelos lineales múltiples, modelos lineales mixtos (LMM) y modelos lineales generalizados mixtos (GLMM), con efectos aleatorios por país y, en algunos casos, por región; y, finalmente, la construcción de una herramienta interactiva, mediante Shiny, que encapsula todo el proceso de análisis, desde la exploración hasta la predicción y validación automática de los modelos.</p>
<p>Este enfoque permite capturar tanto las diferencias estructurales entre países como las dinámicas temporales internas, y facilita una interpretación integrada de los resultados.</p>
</section>
<section id="estructura-del-trabajo" class="level2">
<h2 class="anchored" data-anchor-id="estructura-del-trabajo">Estructura del trabajo</h2>
<p>El contenido del trabajo se organiza en siete capítulos, que se resumen a continuación:</p>
<ul>
<li><p>Capítulo 2 – Datos longitudinales y motivación del análisis: se introduce el concepto de datos longitudinales, sus características específicas, y se justifica la necesidad de utilizar modelos mixtos en lugar de técnicas clásicas de regresión.</p></li>
<li><p>Capítulo 3 – Modelos estadísticos para datos longitudinales: se presenta el marco teórico de los modelos lineales mixtos (LMM) y modelos lineales generalizados mixtos (GLMM), incluyendo su formulación, métodos de estimación, validación y predicción.</p></li>
<li><p>Capítulo 4 – Análisis exploratorio y enriquecimiento de datos: se describen las tareas de limpieza, integración y análisis preliminar de los datos del World Happiness Report, complementados con variables políticas. Se generan visualizaciones y se realiza un modelo de regresión múltiple como aproximación inicial.</p></li>
<li><p>Capítulo 5 – Construcción de modelos predictivos: se aplica una estrategia combinada top-down y bottom-up para ajustar modelos mixtos que expliquen el Happiness Score, evaluando distintas combinaciones de variables y efectos. Se identifican modelos válidos, se analizan sus coeficientes, y se realiza una predicción para el año 2025.</p></li>
<li><p>Capítulo 6 – Aplicación Shiny para modelización interactiva: se describe en detalle la aplicación interactiva desarrollada con Shiny, que permite realizar el análisis completo (exploración, modelización, validación, predicción) desde una interfaz accesible y personalizable.</p></li>
<li><p>Capítulo 7 – Conclusiones y mejoras futuras: se realiza una valoración crítica del trabajo, se identifican las principales aportaciones metodológicas y prácticas, y se proponen posibles líneas de mejora y extensión para trabajos futuros.</p></li>
</ul>
<p>Desde una perspectiva académica, el trabajo constituye una aplicación práctica y completa del análisis de datos longitudinales, integrando técnicas de modelización, visualización, validación y desarrollo de productos reproducibles. Permite consolidar conocimientos adquiridos durante el Grado en Ciencia e Ingeniería de Datos, en especial en estadística, ciencia de datos aplicada y desarrollo en R.</p>
<p>Desde el punto de vista social, el trabajo aborda una problemática de alto interés público: el bienestar global. Al ofrecer una herramienta interactiva para explorar los determinantes de la felicidad en distintos contextos temporales y geográficos, el proyecto puede resultar útil para investigadores, educadores, periodistas o responsables de políticas públicas interesados en promover el bienestar en sus comunidades.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>